<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <title>Scores</title>
        <script src="http://live.12urenloop.be/js/boxxy.js"></script>
        <script src="http://live.12urenloop.be/js/jquery-1.7.1.min.js"></script>
        <script src="http://live.12urenloop.be/socket.io/socket.io.js"></script>
        <script src="http://d3js.org/d3.v3.min.js"></script>

        <link rel="stylesheet" type="text/css" href="http://live.12urenloop.be/css/application.css">
    </head>
    <body>
        <div id="main">
            <div id="navigation">
                <a href="/scores">Scores</a>
                <a href="/dj-contest">DJ Contest</a>
                <a href="/special-laps">Speciale rondes</a>
            </div>
            <div id="content">
                <h1>Scores</h1>
                <div id="notification"></div>
                <div id="ranking"></div>
            </div>
            <div id="footer">
                <p>
                    Built with love by
                    <a href="http://zeus.ugent.be">Zeus WPI</a>.
                </p>
            </div>
        </div>

        <script>
            // Set up boxxy
            var boxxy = boxxy.initialize(),
                boxxyHost = 'http://live.12urenloop.be:8080';

            // Set up D3 vars
            var margin = {top: 15, right: 0, bottom: 0, left: 0},
                width = 460 - margin.left - margin.right,
                rowHeight = 20;

            var rankingSvg,
                numberOfStations,
                interstationDurations,
                stationTimestamps,
                timeFormat;

            $(document).ready(function () {

                // This functions draws the complete visualisation
                // teams should be an array with teams
                // stations should be an array with stations
                function redrawEverything(teams, stations) {
                    // Create a D3 readable array and add ranking
                    var data = addRankingInformation(teams);

                    var height = data.length * rowHeight;

                    timeFormat = d3.time.format.iso;

                    numberOfStations = stations.length;

                    // Set up initial durations
                    interstationDurations = [];
                    stationTimestamps = [];
                    for (var t in teams) {
                        interstationDurations[teams[t].id] = [];
                        stationTimestamps[teams[t].id] = [];
                        for (var s in stations) {
                            interstationDurations[teams[t].id][stations[s].id] = 20000;
                        }
                    }

                    // Set up the main svg
                    rankingSvg = d3.select("#ranking")
                      .append("svg")
                        .attr("viewBox", "0 0 " + (width + margin.left + margin.right) +  " " + (height + margin.top + margin.bottom))
                        .attr("preserveAspectRatio", "xMinYMin meet" )
                      .append("g")
                        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

                    // Add a g for every team
                    var team = rankingSvg.selectAll(".team")
                        .data(data, function(d) { return d.id; })
                      .enter().append("g")
                        .attr("class", "team")
                        .attr("id", function (d) { return "team_" + d.id; })
                        .attr("transform", function (d) { return "translate(0," + (d.rankingPosition * rowHeight) + ")"; });

                    // Add the team position
                    team.append("text")
                        .attr("class", "position")
                        .attr("x", 25)
                        .attr("text-anchor", "end")
                        .text(function (d) { return (d.rankingPosition + 1) + "."; });

                    // Add the team names to the left hand side
                    team.append("text")
                        .attr("class", "teamName")
                        .attr("x", 30)
                        .text(function (d) { return d.name; });

                    // Add the lap count to the right hand side
                    team.append("text")
                        .attr("class", "lapCount")
                        .attr("x", width - 5 - rowHeight)
                        .attr("text-anchor", "end")
                        .text(function (d) { return d3.format(",")(d.laps).replace(",", "."); });

                    // Add a progress spinner background
                    team.append("path")
                        .attr("class", "progressBackgrond")
                        .attr("transform", "translate(" + (width - 10) + ", -5)")
                        .attr("fill-opacity", 0.2)
                        .style("fill", "steelblue")
                        .attr("d", arc(numberOfStations));

                    // Add a progress spinner
                    team.append("path")
                        .attr("class", "progressSpinner")
                        .attr("transform", "translate(" + (width - 10) + ", -5)")
                        .style("fill", "steelblue")
                      .transition()
                        .duration(2000)
                        .attrTween("d", arcTween);

                    // Add a progress bar
                    team.append("rect")
                        .attr("width", 0)
                        .attr("y", -rowHeight + 6)
                        .attr("x", 28)
                        .attr("height", rowHeight - 2)
                        .attr("class", "progressBar")
                        .attr("fill-opacity", 0.5)
                        .style("fill", "steelblue")
                      .transition()
                        .duration(2000)
                        .attrTween("width", barTween);
                }

                // Updates the lapcount and order
                // teams should be an array
                function update(teams) {
                    // Create a D3 readable array and add ranking
                    var data = addRankingInformation(teams);

                    var team = d3.selectAll(".team")
                        .data(data, function(d) { return d.id; })
                      .transition()
                        .duration(3000)
                        .ease("elastic")
                        .attr("transform", function (d) { return "translate(0," + (d.rankingPosition * rowHeight) + ")"; });

                    team.selectAll(".position")
                        .text(function (d) { return (d.rankingPosition + 1) + "."; });

                    team.selectAll(".lapCount")
                        .text(function (d) { return d3.format(",")(d.laps).replace(",", "."); });
                }

                // Updates the progress spinner
                // teamId is the id of the team we need to update
                // station is the logged station
                // timeStamp is the timeStamp of the log event
                // teams is the teams data array
                function updateProgress(teamId, station, timeStamp, teams) {
                    // Create a D3 readable array and add ranking
                    var data = addRankingInformation(teams);

                    var time =timeFormat.parse(timeStamp),
                        previousStation = station - 1 == 0 ? numberOfStations : station - 1,
                        speedCompensation = 1;

                    // basic interpolation
                    if (stationTimestamps[teamId][previousStation] != null) {
                        var newValue = time - stationTimestamps[teamId][previousStation];
                        speedCompensation = newValue / interstationDurations[teamId][previousStation];
                        interstationDurations[teamId][previousStation] = newValue;
                    }
                    stationTimestamps[teamId][station] = time;
                    animationDuration = speedCompensation * interstationDurations[teamId][station] + 2000;

                    var team = d3.selectAll(".team")
                        .data(data, function (d) {return d.id; });

                    team.filter("#team_" + teamId).selectAll(".progressSpinner")
                      .transition()
                        .duration(animationDuration)
                        .ease("linear")
                        .attrTween("d", arcTween);

                    if (station == 1) {
                        var t0 = team.filter("#team_" + teamId).selectAll(".progressBar")
                          .transition()
                            .duration(1000)
                            .attr("fill-opacity", 0);
                        var t1 = t0.transition()
                            .duration(1)
                            .attr("fill-opacity", 0.5);
                        t1.transition()
                            .duration(animationDuration)
                            .ease("linear")
                            .attrTween("width", barTween);
                    }
                    else {
                        team.filter("#team_" + teamId).selectAll(".progressBar")
                          .transition()
                            .duration(animationDuration)
                            .ease("linear")
                            .attrTween("width", barTween);
                    }
                }

                // Adds the position in the ranking to the data
                function addRankingInformation(teams) {
                    var data = teams.sort(function(a, b) { return b.laps - a.laps; });
                    for (var i = 0; i < data.length; i++) {
                        data[i].rankingPosition = i;
                    }
                    return data;
                }

                // Tween the arcs!
                function arcTween(b) {
                    var oldValue = this._current == null ? 0 : this._current,
                        newValue = parseInt(b.station, 10),
                        a = this;

                    if( newValue < oldValue ) {
                      var i = d3.interpolate(0, newValue);
                    } else {
                      var i = d3.interpolate(oldValue, newValue);
                    }
                    return function (t) {
                        a._current = i(t) % (numberOfStations + 0.01);
                        return arc(a._current);
                    };
                }

                // Tween the bars!
                function barTween(b) {
                    var oldValue = this._current == null ? 0 : this._current,
                        newValue = parseInt(b.station, 10),
                        a = this;

                    if( newValue < oldValue ) {
                      var i = d3.interpolate(0, newValue);
                    } else {
                      var i = d3.interpolate(oldValue, newValue);
                    }
                    return function (t) {
                        a._current = i(t) % (numberOfStations + 0.01);
                        return a._current * (410.0 / numberOfStations);
                    };
                }

                var arc = d3.svg.arc()
                    .innerRadius(5)
                    .outerRadius(8)
                    .startAngle(0)
                    .endAngle(function(d) { return (d / numberOfStations) * 2 * Math.PI; });

                // This function gets executed when the state is reset: so either
                // the client initially connects, or when it reconnects after a
                // failure.
                boxxy.onPutState = function (state) {
                    // Out with the old, in with the new
                    $("#ranking").html("");
                    var teams = boxxy.teamsByScore(),
                        stations = [];
                    for (var key in boxxy.stations) {
                        stations.push(boxxy.stations[key]);
                    }
                    redrawEverything(teams, stations);
                };

                // This function gets executed when a team completes a lap.
                boxxy.onAddLap = function (lap) {
                    update(boxxy.teamsByScore());
                };

                boxxy.onUpdatePosition = function (position) {
                    updateProgress(position.team, position.station, position.timestamp, boxxy.teamsByScore());
                };

                boxxy.onUpdate = function () {};

                // Listen to boxxy
                boxxy.listen(boxxyHost);
            });
        </script>
    </body>
</html>
